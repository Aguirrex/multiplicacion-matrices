# HPC Matrix Multiplication (Sequential Version)

> A straightforward, single-threaded implementation demonstrating how to compile, run, and analyze performance for matrix multiplication.

## Compilation

```bash
gcc sequential.c -o sequential
```

## Compiler optimization

To optimize the compilation for better performance:

```bash
gcc -O3 sequential.c -o sequential
```

This will enable the compiler to do high-level optimizations, including:
  - Loop unrolling
  - Vectorization
  - Advanced inlining
  - Other aggressive optimizations to improve execution speed

## Execution

```bash
./sequential [n] [--files matrixA.txt matrixB.txt] [--result outputFile]
```
- When `n` is not provided, it defaults to 2000.
- Optionally, pass `--files` followed by two filenames to read matrices from files, when --files is provided you must provide `n`.
- Optionally, pass `--result` followed by a filename to write the result matrix to a file, when not provided, the result is writed in result.out

## Generating Matrices

Use the included Python script:
```bash
python ../../utils/generate_matrix.py 500 plain_matrices/matrixA.txt
python ../../utils/generate_matrix.py 500 plain_matrices/matrixB.txt
```
Then run:
```bash
./sequential 500 --files plain_matrices/matrixA.txt plain_matrices/matrixB.txt
```

## Profiling with gprof

```bash
gcc -pg -g -o sequential sequential.c
./sequential
gprof -l sequential > gprof.out
```

## Additional Script Details

- **O3_comparation.sh**  
Checks if using `-O3 -floop-interchange` changes the matrix multiplication logic compared to standard compilation. It compiles the code with and without these flags, runs both versions, and compares their outputs to detect any differences.

- **O3_transpose_comparation.sh**  
Compares different compilation and execution flags (`-O3`, `-floop-interchange`, `--transpose`). It compiles each variant, runs them, and logs performance data to highlight the effects of these flags on execution time.

- **main_run.sh**  
Acts as the main testing script, running matrix multiplication for various dimensions and configurations. It gathers execution times across multiple iterations, storing results in a CSV file for later analysis.

- **plot_matrix_results.py**  
Reads the CSV generated by `main_run.sh`, calculates averages, and produces a comparative performance plot. It also prints a summary table and computes speedups for different configurations, offering an overview of their relative performance.


## Code Implementation Details

### Function Implementations:

1. **fillMatrix(int n, int **matrix)**
   - Populates an n×n matrix with random integers (0-9)
   - Uses nested loops to access each element by row and column
   - Time complexity: O(n²)

2. **multiplyMatrix(int n, int **matrix1, int **matrix2, int **resultMatrix)**
   - Performs matrix multiplication: matrix1 × matrix2 = resultMatrix
   - Uses three nested loops: outer two iterate through result matrix coordinates
   - Inner loop calculates dot product for each result cell
   - Time complexity: O(n³)

### Main Function Implementation:

1. **Memory Management**
   - Dynamically allocates three n×n matrices using malloc()
   - Performs error checking after each allocation
   - Properly frees all memory at the end to prevent leaks

2. **Matrix Population**
   - Uses fillMatrix() to populate input matrices with random values

3. **Time Measurement**
   - Uses high-precision CLOCK_MONOTONIC for accurate timing
   - Specifically measures only the matrix multiplication operation

4. **Output**
   - Displays computation time in seconds (9 decimal places)
   - Contains commented code to print matrices (disabled for large N)